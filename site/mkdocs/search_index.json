{
    "docs": [
        {
            "location": "/", 
            "text": "Git Tutorial \nby MG\n\n\n\n\nGit is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n\n\n\n\nTable of Contents\n\n\nThis site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms. \n\n\nGet Started\n\n\n\n\nGet Started with Windows\n\n\nGet Started with Linux\n\n\n\n\nGit Basics\n\n\n\n\nGetting a Git Repository\n\n\nCommit: Recording changes to the repository\n\n\nRecording Changes to the Repository\n\n\nViewing the Commit History\n\n\nUndoing Things\n\n\nWorking with Remotes\n\n\nTagging\n\n\nGit Configurations\n\n\nWorkflow\n\n\nGit Aliases\n\n\n\n\nGit Branching\n\n\n\n\nBranches in a Nutshell\n\n\nBasic Branching and Merging\n\n\nBranch Management\n\n\nBranching Workflows\n\n\nRemote Branches\n\n\nRebasing\n\n\n\n\nGithub\n\n\n\n\nAccount Setup and Configuration\n\n\nCreate an issue\n\n\nContributing to a Project\n\n\nMaintaining a Project\n\n\nManaging an organization\n\n\nScripting GitHub\n\n\n\n\nMiscellaneous\n\n\n\n\nBest git books\n\n\nBest git courses\n\n\nGit videos\n\n\nExternal Links\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nVideos\n\n\n\n\n\n\n\n\nExternal Links\n\n\n\n\nhttps://git-scm.com/\n\n\nOfficial Git Tutorial\n\n\nRy\u2019s Git Tutorial", 
            "title": "Home"
        }, 
        {
            "location": "/#git-tutorial-by-mg", 
            "text": "Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.", 
            "title": "Git Tutorial by MG"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "This site is intended to host a variety of resources and pointers to information about Data Structures and Algorithms.", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#get-started", 
            "text": "Get Started with Windows  Get Started with Linux", 
            "title": "Get Started"
        }, 
        {
            "location": "/#git-basics", 
            "text": "Getting a Git Repository  Commit: Recording changes to the repository  Recording Changes to the Repository  Viewing the Commit History  Undoing Things  Working with Remotes  Tagging  Git Configurations  Workflow  Git Aliases", 
            "title": "Git Basics"
        }, 
        {
            "location": "/#git-branching", 
            "text": "Branches in a Nutshell  Basic Branching and Merging  Branch Management  Branching Workflows  Remote Branches  Rebasing", 
            "title": "Git Branching"
        }, 
        {
            "location": "/#github", 
            "text": "Account Setup and Configuration  Create an issue  Contributing to a Project  Maintaining a Project  Managing an organization  Scripting GitHub", 
            "title": "Github"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "Best git books  Best git courses  Git videos  External Links", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#videos", 
            "text": "", 
            "title": "Videos"
        }, 
        {
            "location": "/#external-links", 
            "text": "https://git-scm.com/  Official Git Tutorial  Ry\u2019s Git Tutorial", 
            "title": "External Links"
        }, 
        {
            "location": "/get_started/", 
            "text": "Windows\n\n\nStep 1. Download the \nGit for Windows installer package\n.\n\n\nStep 2. When you've successfully started the installer, you should see the Git Setup wizard screen. Follow the Next and Finish prompts to complete the installation.\n\n\n\n\nStep 3.Open Git Bash.vbs from the Git folder of the Programs directory to open a command window.\n\n\n\n\nStep 4. Configure your username using the following command\n\n\n$ git config --global user.name \nyour_name\n\n\n\n\n\nStep 5. Configure your email address using the following command\n\n\n$ git config --global user.email \nyour_email\n\n\n\n\n\nLinux\n\n\nStep 1. Enter the following command to install Git:\n\n\n$ sudo apt-get install git\n\n\n\n\nStep 2. Verify the installation was successful by typing which git at the command line.\n\n\n$ which git\n/opt/local/bin/git\n\n\n\n\nStep 3. Configure your username using the following command.\n\n\n$ git config --global user.name \nEmma Paris\n\n\n\n\n\nStep 4. Configure your email address using the following command.\n\n\n$ git config --global user.email \neparis@atlassian.com", 
            "title": "Get Started"
        }, 
        {
            "location": "/get_started/#windows", 
            "text": "Step 1. Download the  Git for Windows installer package .  Step 2. When you've successfully started the installer, you should see the Git Setup wizard screen. Follow the Next and Finish prompts to complete the installation.   Step 3.Open Git Bash.vbs from the Git folder of the Programs directory to open a command window.   Step 4. Configure your username using the following command  $ git config --global user.name  your_name   Step 5. Configure your email address using the following command  $ git config --global user.email  your_email", 
            "title": "Windows"
        }, 
        {
            "location": "/get_started/#linux", 
            "text": "Step 1. Enter the following command to install Git:  $ sudo apt-get install git  Step 2. Verify the installation was successful by typing which git at the command line.  $ which git\n/opt/local/bin/git  Step 3. Configure your username using the following command.  $ git config --global user.name  Emma Paris   Step 4. Configure your email address using the following command.  $ git config --global user.email  eparis@atlassian.com", 
            "title": "Linux"
        }, 
        {
            "location": "/repository/", 
            "text": "Getting a Git Repository\n\n\nIf you can read only one chapter to get going with Git, this is it. This chapter covers every basic command you need to do the vast majority of the things you\u2019ll eventually spend your time doing with Git. By the end of the chapter, you should be able to configure and initialize a repository, begin and stop tracking files, and stage and commit changes. We\u2019ll also show you how to set up Git to ignore certain files and file patterns, how to undo mistakes quickly and easily, how to browse the history of your project and view changes between commits, and how to push and pull from remote repositories.\n\n\nGetting a Git Repository\n\n\nYou can get a Git project using two main approaches. The first takes an existing project or directory and imports it into Git. The second clones an existing Git repository from another server.\n\n\nInitializing a Repository in an Existing Directory\n\n\nIf you\u2019re starting to track an existing project in Git, you need to go to the project\u2019s directory. If you\u2019ve never done this, it looks a little different depending on which system you\u2019re running:\n\n\nfor Linux:\n\n\n$ cd /home/user/your_repository\n\n\n\n\nfor Mac:\n\n\n$ cd /Users/user/your_repository\n\n\n\n\nfor Windows:\n\n\n$ cd /c/user/your_repository\n\n\n\n\nand type:\n\n\n$ git init\n\n\n\n\nThis creates a new subdirectory named \n.git\n that contains all of your necessary repository files \u2013 a Git repository skeleton. At this point, nothing in your project is tracked yet. (See \nGit Internals\n for more information about exactly what files are contained in the .git directory you just created.)\n\n\nIf you want to start version-controlling existing files (as opposed to an empty directory), you should probably begin tracking those files and do an initial commit. You can accomplish that with a few git add commands that specify the files you want to track, followed by a git commit:\n\n\n$ git add *.c\n$ git add LICENSE\n$ git commit -m 'initial project version'\n\n\n\n\nWe\u2019ll go over what these commands do in just a minute. At this point, you have a Git repository with tracked files and an initial commit.\n\n\nCloning an Existing Repository\n\n\nIf you want to get a copy of an existing Git repository \u2013 for example, a project you\u2019d like to contribute to \u2013 the command you need is git clone. If you\u2019re familiar with other VCS systems such as Subversion, you\u2019ll notice that the command is \"clone\" and not \"checkout\". This is an important distinction \u2013 instead of getting just a working copy, Git receives a full copy of nearly all data that the server has. Every version of every file for the history of the project is pulled down by default when you run git clone. In fact, if your server disk gets corrupted, you can often use nearly any of the clones on any client to set the server back to the state it was in when it was cloned (you may lose some server-side hooks and such, but all the versioned data would be there \u2013 see \nGit on the Server\n for more details).\n\n\nYou clone a repository with \ngit clone [url]\n. For example, if you want to clone the Git linkable library called libgit2, you can do so like this:\n\n\n$ git clone https://github.com/libgit2/libgit2\n\n\n\n\nThat creates a directory named \u201clibgit2\u201d, initializes a .git directory inside it, pulls down all the data for that repository, and checks out a working copy of the latest version. If you go into the new libgit2 directory, you\u2019ll see the project files in there, ready to be worked on or used. If you want to clone the repository into a directory named something other than \u201clibgit2\u201d, you can specify that as the next command-line option:\n\n\n$ git clone https://github.com/libgit2/libgit2 mylibgit\n\n\n\n\nThat command does the same thing as the previous one, but the target directory is called mylibgit.\n\n\nGit has a number of different transfer protocols you can use. The previous example uses the \nhttps://\n protocol, but you may also see \ngit://\n or \nluser@server:path/to/repo.git\n, which uses the SSH transfer protocol. \nGit on the Server\n will introduce all of the available options the server can set up to access your Git repository and the pros and cons of each.", 
            "title": "Getting a git repository"
        }, 
        {
            "location": "/repository/#getting-a-git-repository", 
            "text": "If you can read only one chapter to get going with Git, this is it. This chapter covers every basic command you need to do the vast majority of the things you\u2019ll eventually spend your time doing with Git. By the end of the chapter, you should be able to configure and initialize a repository, begin and stop tracking files, and stage and commit changes. We\u2019ll also show you how to set up Git to ignore certain files and file patterns, how to undo mistakes quickly and easily, how to browse the history of your project and view changes between commits, and how to push and pull from remote repositories.", 
            "title": "Getting a Git Repository"
        }, 
        {
            "location": "/repository/#getting-a-git-repository_1", 
            "text": "You can get a Git project using two main approaches. The first takes an existing project or directory and imports it into Git. The second clones an existing Git repository from another server.  Initializing a Repository in an Existing Directory  If you\u2019re starting to track an existing project in Git, you need to go to the project\u2019s directory. If you\u2019ve never done this, it looks a little different depending on which system you\u2019re running:  for Linux:  $ cd /home/user/your_repository  for Mac:  $ cd /Users/user/your_repository  for Windows:  $ cd /c/user/your_repository  and type:  $ git init  This creates a new subdirectory named  .git  that contains all of your necessary repository files \u2013 a Git repository skeleton. At this point, nothing in your project is tracked yet. (See  Git Internals  for more information about exactly what files are contained in the .git directory you just created.)  If you want to start version-controlling existing files (as opposed to an empty directory), you should probably begin tracking those files and do an initial commit. You can accomplish that with a few git add commands that specify the files you want to track, followed by a git commit:  $ git add *.c\n$ git add LICENSE\n$ git commit -m 'initial project version'  We\u2019ll go over what these commands do in just a minute. At this point, you have a Git repository with tracked files and an initial commit.", 
            "title": "Getting a Git Repository"
        }, 
        {
            "location": "/repository/#cloning-an-existing-repository", 
            "text": "If you want to get a copy of an existing Git repository \u2013 for example, a project you\u2019d like to contribute to \u2013 the command you need is git clone. If you\u2019re familiar with other VCS systems such as Subversion, you\u2019ll notice that the command is \"clone\" and not \"checkout\". This is an important distinction \u2013 instead of getting just a working copy, Git receives a full copy of nearly all data that the server has. Every version of every file for the history of the project is pulled down by default when you run git clone. In fact, if your server disk gets corrupted, you can often use nearly any of the clones on any client to set the server back to the state it was in when it was cloned (you may lose some server-side hooks and such, but all the versioned data would be there \u2013 see  Git on the Server  for more details).  You clone a repository with  git clone [url] . For example, if you want to clone the Git linkable library called libgit2, you can do so like this:  $ git clone https://github.com/libgit2/libgit2  That creates a directory named \u201clibgit2\u201d, initializes a .git directory inside it, pulls down all the data for that repository, and checks out a working copy of the latest version. If you go into the new libgit2 directory, you\u2019ll see the project files in there, ready to be worked on or used. If you want to clone the repository into a directory named something other than \u201clibgit2\u201d, you can specify that as the next command-line option:  $ git clone https://github.com/libgit2/libgit2 mylibgit  That command does the same thing as the previous one, but the target directory is called mylibgit.  Git has a number of different transfer protocols you can use. The previous example uses the  https://  protocol, but you may also see  git://  or  luser@server:path/to/repo.git , which uses the SSH transfer protocol.  Git on the Server  will introduce all of the available options the server can set up to access your Git repository and the pros and cons of each.", 
            "title": "Cloning an Existing Repository"
        }, 
        {
            "location": "/commit/", 
            "text": "Commit\n\n\nRecording Changes to the Repository\n\n\nYou have a bona fide Git repository and a checkout or working copy of the files for that project. You need to make some changes and commit snapshots of those changes into your repository each time the project reaches a state you want to record.\n\n\nRemember that each file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. Untracked files are everything else \u2013 any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven\u2019t edited anything.\n\n\nAs you edit files, Git sees them as modified, because you\u2019ve changed them since your last commit. You stage these modified files and then commit all your staged changes, and the cycle repeats.\n\n\n\n\nFigure 8. The lifecycle of the status of your files.\n\n\nChecking the Status of Your Files\n\n\nThe main tool you use to determine which files are in which state is the git status command. If you run this command directly after a clone, you should see something like this:\n\n\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nnothing to commit, working directory clean\n\n\n\n\nThis means you have a clean working directory \u2013 in other words, none of your tracked files are modified. Git also doesn\u2019t see any untracked files, or they would be listed here. Finally, the command tells you which branch you\u2019re on and informs you that it has not diverged from the same branch on the server. For now, that branch is always \u201cmaster\u201d, which is the default; you won\u2019t worry about it here. \nGit Branching\n will go over branches and references in detail.\n\n\nLet\u2019s say you add a new file to your project, a simple README file. If the file didn\u2019t exist before, and you run git status, you see your untracked file like so:\n\n\n$ echo 'My Project' \n README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nUntracked files:\n  (use \ngit add \nfile\n...\n to include in what will be committed)\n\n    README\nnothing added to commit but untracked files present (use \ngit add\n to track)\n\n\n\n\nYou can see that your new README file is untracked, because it\u2019s under the \u201cUntracked files\u201d heading in your status output. Untracked basically means that Git sees a file you didn\u2019t have in the previous snapshot (commit); Git won\u2019t start including it in your commit snapshots until you explicitly tell it to do so. It does this so you don\u2019t accidentally begin including generated binary files or other files that you did not mean to include. You do want to start including README, so let\u2019s start tracking the file.\n\n\nTracking New Files\n\n\nIn order to begin tracking a new file, you use the command \ngit add\n. To begin tracking the README file, you can run this:\n\n\n$ git add README\n\n\n\n\nIf you run your status command again, you can see that your README file is now tracked and staged to be committed:\n\n\n$ git status\n\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    new file:   README\n\n\n\n\nYou can tell that it\u2019s staged because it\u2019s under the \u201cChanges to be committed\u201d heading. If you commit at this point, the version of the file at the time you ran \ngit add\n is what will be in the historical snapshot. You may recall that when you ran \ngit init\n earlier, you then ran \ngit add (files)\n \u2013 that was to begin tracking files in your directory. The \ngit\n add command takes a path name for either a file or a directory; if it\u2019s a directory, the command adds all the files in that directory recursively.\n\n\nStaging Modified Files\n\n\nLet\u2019s change a file that was already tracked. If you change a previously tracked file called \nCONTRIBUTING.md\n and then run your git status command again, you get something that looks like this:\n\n\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    new file:   README\n\nChanges not staged for commit:\n  (use \ngit add \nfile\n...\n to update what will be committed)\n  (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\n\n\n\nThe \nCONTRIBUTING.md\n file appears under a section named \u201cChanges not staged for commit\u201d \u2013 which means that a file that is tracked has been modified in the working directory but not yet staged. To stage it, you run the \ngit add\n command. \ngit add\n is a multipurpose command \u2013 you use it to begin tracking new files, to stage files, and to do other things like marking merge-conflicted files as resolved. It may be helpful to think of it more as \u201cadd this content to the next commit\u201d rather than \u201cadd this file to the project\u201d. Let\u2019s run git add now to stage the \nCONTRIBUTING.md\n file, and then run \ngit status\n again:\n\n\n$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n\n\n\n\nBoth files are staged and will go into your next commit. At this point, suppose you remember one little change that you want to make in \nCONTRIBUTING.md\n before you commit it. You open it again and make that change, and you\u2019re ready to commit. However, let\u2019s run git status one more time:\n\n\n$ vim CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use \ngit add \nfile\n...\n to update what will be committed)\n  (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\n\n\n\nWhat the heck? Now \nCONTRIBUTING.md\n is listed as both staged and unstaged. How is that possible? It turns out that Git stages a file exactly as it is when you run the git add command. If you commit now, the version of \nCONTRIBUTING.md\n as it was when you last ran the git add command is how it will go into the commit, not the version of the file as it looks in your working directory when you run git commit. If you modify a file after you run git add, you have to run git add again to stage the latest version of the file:\n\n\n$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n\n\n\n\nShort Status\n\n\nWhile the \ngit status\n output is pretty comprehensive, it\u2019s also quite wordy. Git also has a short status flag so you can see your changes in a more compact way. If you run git status -s or git status --short you get a far more simplified output from the command:\n\n\n$ git status -s\n M README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt\n\n\n\n\nNew files that aren\u2019t tracked have a \n??\n next to them, new files that have been added to the staging area have an A, modified files have an M and so on. There are two columns to the output - the left-hand column indicates the status of the staging area and the right-hand column indicates the status of the working tree. So for example in that output, the \nREADME\n file is modified in the working directory but not yet staged, while the \nlib/simplegit.rb\n file is modified and staged. The \nRakefile\n was modified, staged and then modified again, so there are changes to it that are both staged and unstaged.\n\n\nIgnoring Files\n\n\nOften, you\u2019ll have a class of files that you don\u2019t want Git to automatically add or even show you as being untracked. These are generally automatically generated files such as log files or files produced by your build system. In such cases, you can create a file listing patterns to match them named .gitignore. Here is an example .gitignore file:\n\n\n$ cat .gitignore\n*.[oa]\n*~\n\n\n\n\nThe first line tells Git to ignore any files ending in \u201c.o\u201d or \u201c.a\u201d \u2013 object and archive files that may be the product of building your code. The second line tells Git to ignore all files whose names end with a tilde (~), which is used by many text editors such as Emacs to mark temporary files. You may also include a log, tmp, or pid directory; automatically generated documentation; and so on. Setting up a .gitignore file before you get going is generally a good idea so you don\u2019t accidentally commit files that you really don\u2019t want in your Git repository.\n\n\nThe rules for the patterns you can put in the \n.gitignore\n file are as follows:\n\n\n\n\nBlank lines or lines starting with # are ignored.\n\n\nStandard glob patterns work.\n\n\nYou can start patterns with a forward slash (/) to avoid recursivity.\n\n\nYou can end patterns with a forward slash (/) to specify a directory.\n\n\nYou can negate a pattern by starting it with an exclamation point (!).\n\n\n\n\nGlob patterns are like simplified regular expressions that shells use. An asterisk (\n*\n) matches zero or more characters; \n[abc]\n matches any character inside the brackets (in this case a, b, or c); a question mark (\n`?) matches a single character; and brackets enclosing characters separated by a hyphen (\n[0-9]\n) matches any character between them (in this case 0 through 9). You can also use two asterisks to match nested directories;\na/**/z\nwould match\na/z\n,\na/b/z\n,\na/b/c/z`, and so on.\n\n\nHere is another example \n.gitignore\n file:\n\n\n# no .a files\n*.a\n\n# but do track lib.a, even though you're ignoring .a files above\n!lib.a\n\n# only ignore the TODO file in the current directory, not subdir/TODO\n/TODO\n\n# ignore all files in the build/ directory\nbuild/\n\n# ignore doc/notes.txt, but not doc/server/arch.txt\ndoc/*.txt\n\n# ignore all .pdf files in the doc/ directory and any of its subdirectories\ndoc/**/*.pdf\n\n\n\n\nTip\n\n\nGitHub maintains a fairly comprehensive list of good .gitignore file examples for dozens of projects and languages at \nhttps://github.com/github/gitignore\n if you want a starting point for your project.\n\n\nViewing Your Staged and Unstaged Changes\n\n\nIf the git status command is too vague for you \u2013 you want to know exactly what you changed, not just which files were changed \u2013 you can use the git diff command. We\u2019ll cover git diff in more detail later, but you\u2019ll probably use it most often to answer these two questions: What have you changed but not yet staged? And what have you staged that you are about to commit? Although git status answers those questions very generally by listing the file names, git diff shows you the exact lines added and removed \u2013 the patch, as it were.\n\n\nLet\u2019s say you edit and stage the README file again and then edit the CONTRIBUTING.md file without staging it. If you run your git status command, you once again see something like this:\n\n\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    modified:   README\n\nChanges not staged for commit:\n  (use \ngit add \nfile\n...\n to update what will be committed)\n  (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\n\n\n\nTo see what you\u2019ve changed but not yet staged, type git diff with no other arguments:\n\n\n$ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's\n\n\n\n\nThat command compares what is in your working directory with what is in your staging area. The result tells you the changes you\u2019ve made that you haven\u2019t yet staged.\n\n\nIf you want to see what you\u2019ve staged that will go into your next commit, you can use git diff --staged. This command compares your staged changes to your last commit:\n\n\n$ git diff --staged\ndiff --git a/README b/README\nnew file mode 100644\nindex 0000000..03902a1\n--- /dev/null\n+++ b/README\n@@ -0,0 +1 @@\n+My Project\n\n\n\n\nIt\u2019s important to note that git diff by itself doesn\u2019t show all changes made since your last commit \u2013 only changes that are still unstaged. This can be confusing, because if you\u2019ve staged all of your changes, git diff will give you no output.\n\n\nFor another example, if you stage the CONTRIBUTING.md file and then edit it, you can use git diff to see the changes in the file that are staged and the changes that are unstaged. If our environment looks like this:\n\n\n$ git add CONTRIBUTING.md\n$ echo '# test line' \n CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use \ngit add \nfile\n...\n to update what will be committed)\n  (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\n\n\n\nNow you can use git diff to see what is still unstaged:\n\n\n$ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 643e24f..87f08c8 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -119,3 +119,4 @@ at the\n ## Starter Projects\n\n See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).\n+# test line\n\n\n\n\nand \ngit diff --cached\n to see what you\u2019ve staged so far (\n--staged\n and \n--cached\n are synonyms):\n\n\n$ git diff --cached\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's\n\n\n\n\nNote\n\n\nGit Diff in an External Tool\n\n\nWe will continue to use the git diff command in various ways throughout the rest of the book. There is another way to look at these diffs if you prefer a graphical or external diff viewing program instead. If you run git difftool instead of git diff, you can view any of these diffs in software like emerge, vimdiff and many more (including commercial products). Run git difftool --tool-help to see what is available on your system.\n\n\nCommitting Your Changes\n\n\nNow that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged \u2013 any files you have created or modified that you haven\u2019t run git add on since you edited them \u2013 won\u2019t go into this commit. They will stay as modified files on your disk. In this case, let\u2019s say that the last time you ran git status, you saw that everything was staged, so you\u2019re ready to commit your changes. The simplest way to commit is to type git commit:\n\n\n$ git commit\n\n\n\n\nDoing so launches your editor of choice. (This is set by your shell\u2019s $EDITOR environment variable \u2013 usually vim or emacs, although you can configure it with whatever you want using the git config --global core.editor command as you saw in Getting Started).\n\n\nThe editor displays the following text (this example is a Vim screen):\n\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n# Your branch is up-to-date with 'origin/master'.\n#\n# Changes to be committed:\n#   new file:   README\n#   modified:   CONTRIBUTING.md\n#\n~\n~\n~\n\n.git/COMMIT_EDITMSG\n 9L, 283C\n\n\n\n\nYou can see that the default commit message contains the latest output of the git status command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you\u2019re committing. (For an even more explicit reminder of what you\u2019ve modified, you can pass the -v option to git commit. Doing so also puts the diff of your change in the editor so you can see exactly what changes you\u2019re committing.) When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).\n\n\nAlternatively, you can type your commit message inline with the commit command by specifying it after a -m flag, like this:\n\n\n$ git commit -m \nStory 182: Fix benchmarks for speed\n\n[master 463dc4f] Story 182: Fix benchmarks for speed\n 2 files changed, 2 insertions(+)\n create mode 100644 README\n\n\n\n\nNow you\u2019ve created your first commit! You can see that the commit has given you some output about itself: which branch you committed to (master), what SHA-1 checksum the commit has (463dc4f), how many files were changed, and statistics about lines added and removed in the commit.\n\n\nRemember that the commit records the snapshot you set up in your staging area. Anything you didn\u2019t stage is still sitting there modified; you can do another commit to add it to your history. Every time you perform a commit, you\u2019re recording a snapshot of your project that you can revert to or compare to later.\n\n\nSkipping the Staging Area\n\n\nAlthough it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow. If you want to skip the staging area, Git provides a simple shortcut. Adding the -a option to the git commit command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the git add part:\n\n\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \ngit add \nfile\n...\n to update what will be committed)\n  (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\nno changes added to commit (use \ngit add\n and/or \ngit commit -a\n)\n$ git commit -a -m 'added new benchmarks'\n[master 83e38c7] added new benchmarks\n 1 file changed, 5 insertions(+), 0 deletions(-)\n\n\n\n\nNotice how you don\u2019t have to run git add on the \nCONTRIBUTING.md\n file in this case before you commit. That\u2019s because the \n-a\n flag includes all changed files. This is convenient, but be careful; sometimes this flag will cause you to include unwanted changes.\n\n\nRemoving Files\n\n\nTo remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit. The git rm command does that, and also removes the file from your working directory so you don\u2019t see it as an untracked file the next time around.\n\n\nIf you simply remove the file from your working directory, it shows up under the \u201cChanged but not updated\u201d (that is, unstaged) area of your git status output:\n\n\n$ rm PROJECTS.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use \ngit add/rm \nfile\n...\n to update what will be committed)\n  (use \ngit checkout -- \nfile\n...\n to discard changes in working directory)\n\n        deleted:    PROJECTS.md\n\nno changes added to commit (use \ngit add\n and/or \ngit commit -a\n)\n\n\n\n\nThen, if you run git rm, it stages the file\u2019s removal:\n\n\n$ git rm PROJECTS.md\nrm 'PROJECTS.md'\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    deleted:    PROJECTS.md\n\n\n\n\nThe next time you commit, the file will be gone and no longer tracked. If you modified the file and added it to the staging area already, you must force the removal with the -f option. This is a safety feature to prevent accidental removal of data that hasn\u2019t yet been recorded in a snapshot and that can\u2019t be recovered from Git.\n\n\nAnother useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. In other words, you may want to keep the file on your hard drive but not have Git track it anymore. This is particularly useful if you forgot to add something to your .gitignore file and accidentally staged it, like a large log file or a bunch of .a compiled files. To do this, use the --cached option:\n\n\n$ git rm --cached README\n\n\n\n\nYou can pass files, directories, and file-glob patterns to the git rm command. That means you can do things such as:\n\n\n$ git rm log/\\*.log\n\n\n\n\nNote the backslash () in front of the *. This is necessary because Git does its own filename expansion in addition to your shell\u2019s filename expansion. This command removes all files that have the .log extension in the log/ directory. Or, you can do something like this:\n\n\n$ git rm \\*~\n\n\n\n\nThis command removes all files whose names end with a ~.\n\n\nMoving Files\n\n\nUnlike many other VCS systems, Git doesn\u2019t explicitly track file movement. If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file. However, Git is pretty smart about figuring that out after the fact \u2013 we\u2019ll deal with detecting file movement a bit later.\n\n\nThus it\u2019s a bit confusing that Git has a mv command. If you want to rename a file in Git, you can run something like:\n\n\n$ git mv file_from file_to\n\n\n\n\nand it works fine. In fact, if you run something like this and look at the status, you\u2019ll see that Git considers it a renamed file:\n\n\n$ git mv README.md README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \ngit reset HEAD \nfile\n...\n to unstage)\n\n    renamed:    README.md -\n README\n\n\n\n\nHowever, this is equivalent to running something like this:\n\n\n$ mv README.md README\n$ git rm README.md\n$ git add README\n\n\n\n\nGit figures out that it\u2019s a rename implicitly, so it doesn\u2019t matter if you rename a file that way or with the mv command. The only real difference is that git mv is one command instead of three \u2013 it\u2019s a convenience function. More importantly, you can use any tool you like to rename a file, and address the add/rm later, before you commit.\n\n\nCheatsheet\n\n\n\n\n# Add file contents to the index\ngit add [filename]\n# Record changes to the repository\ngit commit -m [message]\n# Reset current HEAD to the specified state\ngit reset HEAD~1\n# Switch branches or restore working tree files\ngit checkout HEAD~2\n\n\n\n\nView Status\n\n\ngit status\ngit log\ngit log --since=2015-12-01\ngit log --until=2015-12-01\ngit log --author=\nmagizbox\n\ngit log --grep=\nInit\n\ngit log --oneline origin/master\n\n\n\n\nSuggested Readings\n\n\n\n\nhttp://git-scm.com/book/ca/v1/Git-Basics-Recording-Changes-to-the-Repository", 
            "title": "Commit: Recording changes to the repository"
        }, 
        {
            "location": "/commit/#commit", 
            "text": "Recording Changes to the Repository  You have a bona fide Git repository and a checkout or working copy of the files for that project. You need to make some changes and commit snapshots of those changes into your repository each time the project reaches a state you want to record.  Remember that each file in your working directory can be in one of two states: tracked or untracked. Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged. Untracked files are everything else \u2013 any files in your working directory that were not in your last snapshot and are not in your staging area. When you first clone a repository, all of your files will be tracked and unmodified because Git just checked them out and you haven\u2019t edited anything.  As you edit files, Git sees them as modified, because you\u2019ve changed them since your last commit. You stage these modified files and then commit all your staged changes, and the cycle repeats.   Figure 8. The lifecycle of the status of your files.", 
            "title": "Commit"
        }, 
        {
            "location": "/commit/#checking-the-status-of-your-files", 
            "text": "The main tool you use to determine which files are in which state is the git status command. If you run this command directly after a clone, you should see something like this:  $ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nnothing to commit, working directory clean  This means you have a clean working directory \u2013 in other words, none of your tracked files are modified. Git also doesn\u2019t see any untracked files, or they would be listed here. Finally, the command tells you which branch you\u2019re on and informs you that it has not diverged from the same branch on the server. For now, that branch is always \u201cmaster\u201d, which is the default; you won\u2019t worry about it here.  Git Branching  will go over branches and references in detail.  Let\u2019s say you add a new file to your project, a simple README file. If the file didn\u2019t exist before, and you run git status, you see your untracked file like so:  $ echo 'My Project'   README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nUntracked files:\n  (use  git add  file ...  to include in what will be committed)\n\n    README\nnothing added to commit but untracked files present (use  git add  to track)  You can see that your new README file is untracked, because it\u2019s under the \u201cUntracked files\u201d heading in your status output. Untracked basically means that Git sees a file you didn\u2019t have in the previous snapshot (commit); Git won\u2019t start including it in your commit snapshots until you explicitly tell it to do so. It does this so you don\u2019t accidentally begin including generated binary files or other files that you did not mean to include. You do want to start including README, so let\u2019s start tracking the file.", 
            "title": "Checking the Status of Your Files"
        }, 
        {
            "location": "/commit/#tracking-new-files", 
            "text": "In order to begin tracking a new file, you use the command  git add . To begin tracking the README file, you can run this:  $ git add README  If you run your status command again, you can see that your README file is now tracked and staged to be committed:  $ git status\n\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    new file:   README  You can tell that it\u2019s staged because it\u2019s under the \u201cChanges to be committed\u201d heading. If you commit at this point, the version of the file at the time you ran  git add  is what will be in the historical snapshot. You may recall that when you ran  git init  earlier, you then ran  git add (files)  \u2013 that was to begin tracking files in your directory. The  git  add command takes a path name for either a file or a directory; if it\u2019s a directory, the command adds all the files in that directory recursively.", 
            "title": "Tracking New Files"
        }, 
        {
            "location": "/commit/#staging-modified-files", 
            "text": "Let\u2019s change a file that was already tracked. If you change a previously tracked file called  CONTRIBUTING.md  and then run your git status command again, you get something that looks like this:  $ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    new file:   README\n\nChanges not staged for commit:\n  (use  git add  file ...  to update what will be committed)\n  (use  git checkout --  file ...  to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md  The  CONTRIBUTING.md  file appears under a section named \u201cChanges not staged for commit\u201d \u2013 which means that a file that is tracked has been modified in the working directory but not yet staged. To stage it, you run the  git add  command.  git add  is a multipurpose command \u2013 you use it to begin tracking new files, to stage files, and to do other things like marking merge-conflicted files as resolved. It may be helpful to think of it more as \u201cadd this content to the next commit\u201d rather than \u201cadd this file to the project\u201d. Let\u2019s run git add now to stage the  CONTRIBUTING.md  file, and then run  git status  again:  $ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md  Both files are staged and will go into your next commit. At this point, suppose you remember one little change that you want to make in  CONTRIBUTING.md  before you commit it. You open it again and make that change, and you\u2019re ready to commit. However, let\u2019s run git status one more time:  $ vim CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use  git add  file ...  to update what will be committed)\n  (use  git checkout --  file ...  to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md  What the heck? Now  CONTRIBUTING.md  is listed as both staged and unstaged. How is that possible? It turns out that Git stages a file exactly as it is when you run the git add command. If you commit now, the version of  CONTRIBUTING.md  as it was when you last ran the git add command is how it will go into the commit, not the version of the file as it looks in your working directory when you run git commit. If you modify a file after you run git add, you have to run git add again to stage the latest version of the file:  $ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    new file:   README\n    modified:   CONTRIBUTING.md", 
            "title": "Staging Modified Files"
        }, 
        {
            "location": "/commit/#short-status", 
            "text": "While the  git status  output is pretty comprehensive, it\u2019s also quite wordy. Git also has a short status flag so you can see your changes in a more compact way. If you run git status -s or git status --short you get a far more simplified output from the command:  $ git status -s\n M README\nMM Rakefile\nA  lib/git.rb\nM  lib/simplegit.rb\n?? LICENSE.txt  New files that aren\u2019t tracked have a  ??  next to them, new files that have been added to the staging area have an A, modified files have an M and so on. There are two columns to the output - the left-hand column indicates the status of the staging area and the right-hand column indicates the status of the working tree. So for example in that output, the  README  file is modified in the working directory but not yet staged, while the  lib/simplegit.rb  file is modified and staged. The  Rakefile  was modified, staged and then modified again, so there are changes to it that are both staged and unstaged.", 
            "title": "Short Status"
        }, 
        {
            "location": "/commit/#ignoring-files", 
            "text": "Often, you\u2019ll have a class of files that you don\u2019t want Git to automatically add or even show you as being untracked. These are generally automatically generated files such as log files or files produced by your build system. In such cases, you can create a file listing patterns to match them named .gitignore. Here is an example .gitignore file:  $ cat .gitignore\n*.[oa]\n*~  The first line tells Git to ignore any files ending in \u201c.o\u201d or \u201c.a\u201d \u2013 object and archive files that may be the product of building your code. The second line tells Git to ignore all files whose names end with a tilde (~), which is used by many text editors such as Emacs to mark temporary files. You may also include a log, tmp, or pid directory; automatically generated documentation; and so on. Setting up a .gitignore file before you get going is generally a good idea so you don\u2019t accidentally commit files that you really don\u2019t want in your Git repository.  The rules for the patterns you can put in the  .gitignore  file are as follows:   Blank lines or lines starting with # are ignored.  Standard glob patterns work.  You can start patterns with a forward slash (/) to avoid recursivity.  You can end patterns with a forward slash (/) to specify a directory.  You can negate a pattern by starting it with an exclamation point (!).   Glob patterns are like simplified regular expressions that shells use. An asterisk ( * ) matches zero or more characters;  [abc]  matches any character inside the brackets (in this case a, b, or c); a question mark ( `?) matches a single character; and brackets enclosing characters separated by a hyphen ( [0-9] ) matches any character between them (in this case 0 through 9). You can also use two asterisks to match nested directories; a/**/z would match a/z , a/b/z , a/b/c/z`, and so on.  Here is another example  .gitignore  file:  # no .a files\n*.a\n\n# but do track lib.a, even though you're ignoring .a files above\n!lib.a\n\n# only ignore the TODO file in the current directory, not subdir/TODO\n/TODO\n\n# ignore all files in the build/ directory\nbuild/\n\n# ignore doc/notes.txt, but not doc/server/arch.txt\ndoc/*.txt\n\n# ignore all .pdf files in the doc/ directory and any of its subdirectories\ndoc/**/*.pdf  Tip  GitHub maintains a fairly comprehensive list of good .gitignore file examples for dozens of projects and languages at  https://github.com/github/gitignore  if you want a starting point for your project.", 
            "title": "Ignoring Files"
        }, 
        {
            "location": "/commit/#viewing-your-staged-and-unstaged-changes", 
            "text": "If the git status command is too vague for you \u2013 you want to know exactly what you changed, not just which files were changed \u2013 you can use the git diff command. We\u2019ll cover git diff in more detail later, but you\u2019ll probably use it most often to answer these two questions: What have you changed but not yet staged? And what have you staged that you are about to commit? Although git status answers those questions very generally by listing the file names, git diff shows you the exact lines added and removed \u2013 the patch, as it were.  Let\u2019s say you edit and stage the README file again and then edit the CONTRIBUTING.md file without staging it. If you run your git status command, you once again see something like this:  $ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    modified:   README\n\nChanges not staged for commit:\n  (use  git add  file ...  to update what will be committed)\n  (use  git checkout --  file ...  to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md  To see what you\u2019ve changed but not yet staged, type git diff with no other arguments:  $ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's  That command compares what is in your working directory with what is in your staging area. The result tells you the changes you\u2019ve made that you haven\u2019t yet staged.  If you want to see what you\u2019ve staged that will go into your next commit, you can use git diff --staged. This command compares your staged changes to your last commit:  $ git diff --staged\ndiff --git a/README b/README\nnew file mode 100644\nindex 0000000..03902a1\n--- /dev/null\n+++ b/README\n@@ -0,0 +1 @@\n+My Project  It\u2019s important to note that git diff by itself doesn\u2019t show all changes made since your last commit \u2013 only changes that are still unstaged. This can be confusing, because if you\u2019ve staged all of your changes, git diff will give you no output.  For another example, if you stage the CONTRIBUTING.md file and then edit it, you can use git diff to see the changes in the file that are staged and the changes that are unstaged. If our environment looks like this:  $ git add CONTRIBUTING.md\n$ echo '# test line'   CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    modified:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use  git add  file ...  to update what will be committed)\n  (use  git checkout --  file ...  to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md  Now you can use git diff to see what is still unstaged:  $ git diff\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 643e24f..87f08c8 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -119,3 +119,4 @@ at the\n ## Starter Projects\n\n See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).\n+# test line  and  git diff --cached  to see what you\u2019ve staged so far ( --staged  and  --cached  are synonyms):  $ git diff --cached\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nindex 8ebb991..643e24f 100644\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -65,7 +65,8 @@ branch directly, things can get messy.\n Please include a nice description of your changes when you submit your PR;\n if we have to read the whole diff to figure out why you're contributing\n in the first place, you're less likely to get feedback and have your change\n-merged in.\n+merged in. Also, split your changes into comprehensive chunks if your patch is\n+longer than a dozen lines.\n\n If you are starting to work on a particular area, feel free to submit a PR\n that highlights your work in progress (and note in the PR title that it's  Note  Git Diff in an External Tool  We will continue to use the git diff command in various ways throughout the rest of the book. There is another way to look at these diffs if you prefer a graphical or external diff viewing program instead. If you run git difftool instead of git diff, you can view any of these diffs in software like emerge, vimdiff and many more (including commercial products). Run git difftool --tool-help to see what is available on your system.", 
            "title": "Viewing Your Staged and Unstaged Changes"
        }, 
        {
            "location": "/commit/#committing-your-changes", 
            "text": "Now that your staging area is set up the way you want it, you can commit your changes. Remember that anything that is still unstaged \u2013 any files you have created or modified that you haven\u2019t run git add on since you edited them \u2013 won\u2019t go into this commit. They will stay as modified files on your disk. In this case, let\u2019s say that the last time you ran git status, you saw that everything was staged, so you\u2019re ready to commit your changes. The simplest way to commit is to type git commit:  $ git commit  Doing so launches your editor of choice. (This is set by your shell\u2019s $EDITOR environment variable \u2013 usually vim or emacs, although you can configure it with whatever you want using the git config --global core.editor command as you saw in Getting Started).  The editor displays the following text (this example is a Vim screen):  # Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n# Your branch is up-to-date with 'origin/master'.\n#\n# Changes to be committed:\n#   new file:   README\n#   modified:   CONTRIBUTING.md\n#\n~\n~\n~ .git/COMMIT_EDITMSG  9L, 283C  You can see that the default commit message contains the latest output of the git status command commented out and one empty line on top. You can remove these comments and type your commit message, or you can leave them there to help you remember what you\u2019re committing. (For an even more explicit reminder of what you\u2019ve modified, you can pass the -v option to git commit. Doing so also puts the diff of your change in the editor so you can see exactly what changes you\u2019re committing.) When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).  Alternatively, you can type your commit message inline with the commit command by specifying it after a -m flag, like this:  $ git commit -m  Story 182: Fix benchmarks for speed \n[master 463dc4f] Story 182: Fix benchmarks for speed\n 2 files changed, 2 insertions(+)\n create mode 100644 README  Now you\u2019ve created your first commit! You can see that the commit has given you some output about itself: which branch you committed to (master), what SHA-1 checksum the commit has (463dc4f), how many files were changed, and statistics about lines added and removed in the commit.  Remember that the commit records the snapshot you set up in your staging area. Anything you didn\u2019t stage is still sitting there modified; you can do another commit to add it to your history. Every time you perform a commit, you\u2019re recording a snapshot of your project that you can revert to or compare to later.", 
            "title": "Committing Your Changes"
        }, 
        {
            "location": "/commit/#skipping-the-staging-area", 
            "text": "Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow. If you want to skip the staging area, Git provides a simple shortcut. Adding the -a option to the git commit command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the git add part:  $ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use  git add  file ...  to update what will be committed)\n  (use  git checkout --  file ...  to discard changes in working directory)\n\n    modified:   CONTRIBUTING.md\n\nno changes added to commit (use  git add  and/or  git commit -a )\n$ git commit -a -m 'added new benchmarks'\n[master 83e38c7] added new benchmarks\n 1 file changed, 5 insertions(+), 0 deletions(-)  Notice how you don\u2019t have to run git add on the  CONTRIBUTING.md  file in this case before you commit. That\u2019s because the  -a  flag includes all changed files. This is convenient, but be careful; sometimes this flag will cause you to include unwanted changes.", 
            "title": "Skipping the Staging Area"
        }, 
        {
            "location": "/commit/#removing-files", 
            "text": "To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit. The git rm command does that, and also removes the file from your working directory so you don\u2019t see it as an untracked file the next time around.  If you simply remove the file from your working directory, it shows up under the \u201cChanged but not updated\u201d (that is, unstaged) area of your git status output:  $ rm PROJECTS.md\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges not staged for commit:\n  (use  git add/rm  file ...  to update what will be committed)\n  (use  git checkout --  file ...  to discard changes in working directory)\n\n        deleted:    PROJECTS.md\n\nno changes added to commit (use  git add  and/or  git commit -a )  Then, if you run git rm, it stages the file\u2019s removal:  $ git rm PROJECTS.md\nrm 'PROJECTS.md'\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    deleted:    PROJECTS.md  The next time you commit, the file will be gone and no longer tracked. If you modified the file and added it to the staging area already, you must force the removal with the -f option. This is a safety feature to prevent accidental removal of data that hasn\u2019t yet been recorded in a snapshot and that can\u2019t be recovered from Git.  Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. In other words, you may want to keep the file on your hard drive but not have Git track it anymore. This is particularly useful if you forgot to add something to your .gitignore file and accidentally staged it, like a large log file or a bunch of .a compiled files. To do this, use the --cached option:  $ git rm --cached README  You can pass files, directories, and file-glob patterns to the git rm command. That means you can do things such as:  $ git rm log/\\*.log  Note the backslash () in front of the *. This is necessary because Git does its own filename expansion in addition to your shell\u2019s filename expansion. This command removes all files that have the .log extension in the log/ directory. Or, you can do something like this:  $ git rm \\*~  This command removes all files whose names end with a ~.", 
            "title": "Removing Files"
        }, 
        {
            "location": "/commit/#moving-files", 
            "text": "Unlike many other VCS systems, Git doesn\u2019t explicitly track file movement. If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file. However, Git is pretty smart about figuring that out after the fact \u2013 we\u2019ll deal with detecting file movement a bit later.  Thus it\u2019s a bit confusing that Git has a mv command. If you want to rename a file in Git, you can run something like:  $ git mv file_from file_to  and it works fine. In fact, if you run something like this and look at the status, you\u2019ll see that Git considers it a renamed file:  $ git mv README.md README\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use  git reset HEAD  file ...  to unstage)\n\n    renamed:    README.md -  README  However, this is equivalent to running something like this:  $ mv README.md README\n$ git rm README.md\n$ git add README  Git figures out that it\u2019s a rename implicitly, so it doesn\u2019t matter if you rename a file that way or with the mv command. The only real difference is that git mv is one command instead of three \u2013 it\u2019s a convenience function. More importantly, you can use any tool you like to rename a file, and address the add/rm later, before you commit.", 
            "title": "Moving Files"
        }, 
        {
            "location": "/commit/#cheatsheet", 
            "text": "# Add file contents to the index\ngit add [filename]\n# Record changes to the repository\ngit commit -m [message]\n# Reset current HEAD to the specified state\ngit reset HEAD~1\n# Switch branches or restore working tree files\ngit checkout HEAD~2  View Status  git status\ngit log\ngit log --since=2015-12-01\ngit log --until=2015-12-01\ngit log --author= magizbox \ngit log --grep= Init \ngit log --oneline origin/master", 
            "title": "Cheatsheet"
        }, 
        {
            "location": "/commit/#suggested-readings", 
            "text": "http://git-scm.com/book/ca/v1/Git-Basics-Recording-Changes-to-the-Repository", 
            "title": "Suggested Readings"
        }, 
        {
            "location": "/tagging/", 
            "text": "Tagging\n\n\nLike most VCSs, Git has the ability to tag specific points in history as being important. Typically people use this functionality to mark release points (v1.0, and so on). In this section, you\u2019ll learn how to list the available tags, how to create new tags, and what the different types of tags are.\n\n\nListing Your Tags\n\n\nListing the available tags in Git is straightforward. Just type git tag:\n\n\n$ git tag\nv0.1\nv1.3\n\n\n\n\nThis command lists the tags in alphabetical order; the order in which they appear has no real importance.\n\n\nYou can also search for tags with a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you\u2019re only interested in looking at the 1.8.5 series, you can run this:\n\n\n$ git tag -l \nv1.8.5*\n\nv1.8.5\nv1.8.5-rc0\nv1.8.5-rc1\nv1.8.5-rc2\nv1.8.5-rc3\nv1.8.5.1\nv1.8.5.2\nv1.8.5.3\nv1.8.5.4\nv1.8.5.5\n\n\n\n\nCreating Tags\n\n\nGit uses two main types of tags: lightweight and annotated.\n\n\nA lightweight tag is very much like a branch that doesn\u2019t change \u2013 it\u2019s just a pointer to a specific commit.\n\n\nAnnotated tags, however, are stored as full objects in the Git database. They\u2019re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It\u2019s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don\u2019t want to keep the other information, lightweight tags are available too.\n\n\nAnnotated Tags\n\n\nCreating an annotated tag in Git is simple. The easiest way is to specify -a when you run the tag command:\n\n\n$ git tag -a v1.4 -m \nmy version 1.4\n\n$ git tag\nv0.1\nv1.3\nv1.4\n\n\n\n\nThe -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in.\n\n\nYou can see the tag data along with the commit that was tagged by using the git show command:\n\n\n$ git show v1.4\ntag v1.4\nTagger: Ben Straub \nben@straub.cc\n\nDate:   Sat May 3 20:19:12 2014 -0700\n\nmy version 1.4\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon \nschacon@gee-mail.com\n\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n\n\n\n\nThat shows the tagger information, the date the commit was tagged, and the annotation message before showing the commit information.\n\n\nLightweight Tags\n\n\nAnother way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file \u2013 no other information is kept. To create a lightweight tag, don\u2019t supply the -a, -s, or -m option:\n\n\n$ git tag v1.4-lw\n$ git tag\nv0.1\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n\n\n\nThis time, if you run git show on the tag, you don\u2019t see the extra tag information. The command just shows the commit:\n\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon \nschacon@gee-mail.com\n\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n\n\n\n\nTagging Later\n\n\nYou can also tag commits after you\u2019ve moved past them. Suppose your commit history looks like this:\n\n\n$ git log --pretty=oneline\n15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\na6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\n0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\n6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\n4682c3261057305bdd616e23b64b0857d832627b added a todo file\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n\n\nNow, suppose you forgot to tag the project at v1.2, which was at the \u201cupdated rakefile\u201d commit. You can add it after the fact. To tag that commit, you specify the commit checksum (or part of it) at the end of the command:\n\n\n$ git tag -a v1.2 9fceb02\n\n\n\n\nYou can see that you\u2019ve tagged the commit:\n\n\n$ git tag\nv0.1\nv1.2\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n$ git show v1.2\ntag v1.2\nTagger: Scott Chacon \nschacon@gee-mail.com\n\nDate:   Mon Feb 9 15:32:16 2009 -0800\n\nversion 1.2\ncommit 9fceb02d0ae598e95dc970b74767f19372d61af8\nAuthor: Magnus Chacon \nmchacon@gee-mail.com\n\nDate:   Sun Apr 27 20:43:35 2008 -0700\n\n    updated rakefile\n...\n\n\n\n\nSharing Tags\n\n\nBy default, the git push command doesn\u2019t transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches \u2013 you can run git push origin [tagname].\n\n\n$ git push origin v1.5\nCounting objects: 14, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (12/12), done.\nWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\nTotal 14 (delta 3), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.5 -\n v1.5\n\n\n\n\nIf you have a lot of tags that you want to push up at once, you can also use the --tags option to the git push command. This will transfer all of your tags to the remote server that are not already there.\n\n\n$ git push origin --tags\nCounting objects: 1, done.\nWriting objects: 100% (1/1), 160 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.4 -\n v1.4\n * [new tag]         v1.4-lw -\n v1.4-lw\n\n\n\n\nNow, when someone else clones or pulls from your repository, they will get all your tags as well.\n\n\nChecking out Tags\n\n\nYou can\u2019t really check out a tag in Git, since they can\u2019t be moved around. If you want to put a version of your repository in your working directory that looks like a specific tag, you can create a new branch at a specific tag with git checkout -b [branchname] [tagname]:\n\n\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n\n\n\n\nOf course if you do this and do a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.\n\n\nSuggested Readings\n\n\n\n\nGit-Basics-Tagging", 
            "title": "Tagging"
        }, 
        {
            "location": "/tagging/#tagging", 
            "text": "Like most VCSs, Git has the ability to tag specific points in history as being important. Typically people use this functionality to mark release points (v1.0, and so on). In this section, you\u2019ll learn how to list the available tags, how to create new tags, and what the different types of tags are.", 
            "title": "Tagging"
        }, 
        {
            "location": "/tagging/#listing-your-tags", 
            "text": "Listing the available tags in Git is straightforward. Just type git tag:  $ git tag\nv0.1\nv1.3  This command lists the tags in alphabetical order; the order in which they appear has no real importance.  You can also search for tags with a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you\u2019re only interested in looking at the 1.8.5 series, you can run this:  $ git tag -l  v1.8.5* \nv1.8.5\nv1.8.5-rc0\nv1.8.5-rc1\nv1.8.5-rc2\nv1.8.5-rc3\nv1.8.5.1\nv1.8.5.2\nv1.8.5.3\nv1.8.5.4\nv1.8.5.5", 
            "title": "Listing Your Tags"
        }, 
        {
            "location": "/tagging/#creating-tags", 
            "text": "Git uses two main types of tags: lightweight and annotated.  A lightweight tag is very much like a branch that doesn\u2019t change \u2013 it\u2019s just a pointer to a specific commit.  Annotated tags, however, are stored as full objects in the Git database. They\u2019re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It\u2019s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don\u2019t want to keep the other information, lightweight tags are available too.", 
            "title": "Creating Tags"
        }, 
        {
            "location": "/tagging/#annotated-tags", 
            "text": "Creating an annotated tag in Git is simple. The easiest way is to specify -a when you run the tag command:  $ git tag -a v1.4 -m  my version 1.4 \n$ git tag\nv0.1\nv1.3\nv1.4  The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in.  You can see the tag data along with the commit that was tagged by using the git show command:  $ git show v1.4\ntag v1.4\nTagger: Ben Straub  ben@straub.cc \nDate:   Sat May 3 20:19:12 2014 -0700\n\nmy version 1.4\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon  schacon@gee-mail.com \nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number  That shows the tagger information, the date the commit was tagged, and the annotation message before showing the commit information.", 
            "title": "Annotated Tags"
        }, 
        {
            "location": "/tagging/#lightweight-tags", 
            "text": "Another way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file \u2013 no other information is kept. To create a lightweight tag, don\u2019t supply the -a, -s, or -m option:  $ git tag v1.4-lw\n$ git tag\nv0.1\nv1.3\nv1.4\nv1.4-lw\nv1.5  This time, if you run git show on the tag, you don\u2019t see the extra tag information. The command just shows the commit:  $ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon  schacon@gee-mail.com \nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number", 
            "title": "Lightweight Tags"
        }, 
        {
            "location": "/tagging/#tagging-later", 
            "text": "You can also tag commits after you\u2019ve moved past them. Suppose your commit history looks like this:  $ git log --pretty=oneline\n15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\na6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\n0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\n6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\n4682c3261057305bdd616e23b64b0857d832627b added a todo file\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme  Now, suppose you forgot to tag the project at v1.2, which was at the \u201cupdated rakefile\u201d commit. You can add it after the fact. To tag that commit, you specify the commit checksum (or part of it) at the end of the command:  $ git tag -a v1.2 9fceb02  You can see that you\u2019ve tagged the commit:  $ git tag\nv0.1\nv1.2\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n$ git show v1.2\ntag v1.2\nTagger: Scott Chacon  schacon@gee-mail.com \nDate:   Mon Feb 9 15:32:16 2009 -0800\n\nversion 1.2\ncommit 9fceb02d0ae598e95dc970b74767f19372d61af8\nAuthor: Magnus Chacon  mchacon@gee-mail.com \nDate:   Sun Apr 27 20:43:35 2008 -0700\n\n    updated rakefile\n...", 
            "title": "Tagging Later"
        }, 
        {
            "location": "/tagging/#sharing-tags", 
            "text": "By default, the git push command doesn\u2019t transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches \u2013 you can run git push origin [tagname].  $ git push origin v1.5\nCounting objects: 14, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (12/12), done.\nWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\nTotal 14 (delta 3), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.5 -  v1.5  If you have a lot of tags that you want to push up at once, you can also use the --tags option to the git push command. This will transfer all of your tags to the remote server that are not already there.  $ git push origin --tags\nCounting objects: 1, done.\nWriting objects: 100% (1/1), 160 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.4 -  v1.4\n * [new tag]         v1.4-lw -  v1.4-lw  Now, when someone else clones or pulls from your repository, they will get all your tags as well.", 
            "title": "Sharing Tags"
        }, 
        {
            "location": "/tagging/#checking-out-tags", 
            "text": "You can\u2019t really check out a tag in Git, since they can\u2019t be moved around. If you want to put a version of your repository in your working directory that looks like a specific tag, you can create a new branch at a specific tag with git checkout -b [branchname] [tagname]:  $ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'  Of course if you do this and do a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.", 
            "title": "Checking out Tags"
        }, 
        {
            "location": "/tagging/#suggested-readings", 
            "text": "Git-Basics-Tagging", 
            "title": "Suggested Readings"
        }, 
        {
            "location": "/submodule/", 
            "text": "Git Sub Module\n\n\nAdd new submodule\n\n\ngit submodule add https://github.com/chaconinc/DbConnector\n\n\n\n\nUpdate submodule\n\n\ngit submodule init\ngit submodule update", 
            "title": "Submodule"
        }, 
        {
            "location": "/submodule/#git-sub-module", 
            "text": "", 
            "title": "Git Sub Module"
        }, 
        {
            "location": "/submodule/#add-new-submodule", 
            "text": "git submodule add https://github.com/chaconinc/DbConnector", 
            "title": "Add new submodule"
        }, 
        {
            "location": "/submodule/#update-submodule", 
            "text": "git submodule init\ngit submodule update", 
            "title": "Update submodule"
        }, 
        {
            "location": "/config/", 
            "text": "Git Configurations\n\n\nHow do I force git to use LF instead of CR+LF under windows?\n\n\nThe proper way to get LF endings in Windows is to first set core.autocrlf to false:\n\n\ngit config --global core.autocrlf false\n\n\n\n\nSuggested Readings\n\n\n\n\nHow do I force git to use LF instead of CR+LF under windows?", 
            "title": "Git Configurations"
        }, 
        {
            "location": "/config/#git-configurations", 
            "text": "", 
            "title": "Git Configurations"
        }, 
        {
            "location": "/config/#how-do-i-force-git-to-use-lf-instead-of-crlf-under-windows", 
            "text": "The proper way to get LF endings in Windows is to first set core.autocrlf to false:  git config --global core.autocrlf false", 
            "title": "How do I force git to use LF instead of CR+LF under windows?"
        }, 
        {
            "location": "/config/#suggested-readings", 
            "text": "How do I force git to use LF instead of CR+LF under windows?", 
            "title": "Suggested Readings"
        }, 
        {
            "location": "/team_workflow/", 
            "text": "Team Workflow\n\n\nIn this article, I will represent our workflow with git to collaboration. As you can see, there are \nupstream\n, \nA\n, \nB\n repositories. Upstream repostiroy is main repository of project, owner by team leader. \nA\n and \nB\n repositories belong to developers. In \nupstream\n remote, there are \nmaster\n and \ndevelop\n branches. In developer's repositories, there are \ndevelop\n and \nfeature-something\n branches.\n\n\n\n\nStep 1: Create new project\n\n\nIn step 1, leader create a repository.\n\n\n\n\nStep 2: Forking\n\n\nIn step 2, each developers create their own repository by forking main repository\n\n\n\n\nStep 3: Commits\n\n\nIn step 3, developers work on their branches, each peace of their works should be end by a \ncommit\n\n\n\n\nStep 4: Merge Requests\n\n\nAfter finish a feature, each developer will create a \nmerge requests\n to main repository. Leader take responsibility for merging their requests\n\n\n\n\nStep 5: Fetch and Rebase\n\n\nDeveloper will checkout to \ndevelop\n branch, fetch from upstream remote and rebase\n\n\n\n\nStep 6: Develop new features\n\n\nTeam sync\n. At this moment, developer can \ncheckout\n from \ndevelop\n branch to create new feature.\n\n\n\n\nStep 7: New version\n\n\nLeader take responsibility to merge from dev branch to master branch and create tag to release new version.\n\n\n\n\nRelated Readings\n\n\n\n\n\"Git With Development, Staging And Production Branches\". \nstackoverflow.com\n. N.p., 2016. Web. 28 Oct. 2016.\n\n\n\"A Successful Git Branching Model\". \nnvie.com\n. N.p., 2016. Web. 28 Oct. 2016.", 
            "title": "Workflow"
        }, 
        {
            "location": "/team_workflow/#team-workflow", 
            "text": "In this article, I will represent our workflow with git to collaboration. As you can see, there are  upstream ,  A ,  B  repositories. Upstream repostiroy is main repository of project, owner by team leader.  A  and  B  repositories belong to developers. In  upstream  remote, there are  master  and  develop  branches. In developer's repositories, there are  develop  and  feature-something  branches.", 
            "title": "Team Workflow"
        }, 
        {
            "location": "/team_workflow/#step-1-create-new-project", 
            "text": "In step 1, leader create a repository.", 
            "title": "Step 1: Create new project"
        }, 
        {
            "location": "/team_workflow/#step-2-forking", 
            "text": "In step 2, each developers create their own repository by forking main repository", 
            "title": "Step 2: Forking"
        }, 
        {
            "location": "/team_workflow/#step-3-commits", 
            "text": "In step 3, developers work on their branches, each peace of their works should be end by a  commit", 
            "title": "Step 3: Commits"
        }, 
        {
            "location": "/team_workflow/#step-4-merge-requests", 
            "text": "After finish a feature, each developer will create a  merge requests  to main repository. Leader take responsibility for merging their requests", 
            "title": "Step 4: Merge Requests"
        }, 
        {
            "location": "/team_workflow/#step-5-fetch-and-rebase", 
            "text": "Developer will checkout to  develop  branch, fetch from upstream remote and rebase", 
            "title": "Step 5: Fetch and Rebase"
        }, 
        {
            "location": "/team_workflow/#step-6-develop-new-features", 
            "text": "Team sync . At this moment, developer can  checkout  from  develop  branch to create new feature.", 
            "title": "Step 6: Develop new features"
        }, 
        {
            "location": "/team_workflow/#step-7-new-version", 
            "text": "Leader take responsibility to merge from dev branch to master branch and create tag to release new version.", 
            "title": "Step 7: New version"
        }, 
        {
            "location": "/team_workflow/#related-readings", 
            "text": "\"Git With Development, Staging And Production Branches\".  stackoverflow.com . N.p., 2016. Web. 28 Oct. 2016.  \"A Successful Git Branching Model\".  nvie.com . N.p., 2016. Web. 28 Oct. 2016.", 
            "title": "Related Readings"
        }, 
        {
            "location": "/branch/", 
            "text": "Branches\n\n\nA \nbranch\n represents an independent line of development. Branches serve as an abstraction for the \nedit \n stage \n commit\n process discussed in Git Basics, the first module of this series. You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.\n\n\ngit branches diagram\n\n\n\n\n\nLocal Branches\n\n\n# view branches\ngit branch\n# create new branch\ngit checkout -b [branchname]\n# switch to a branch\ngit checkout [branchname]\n# delete branch\ngit branch -D [branchname]\n\n\n\n\nMerge Branches\n\n\ngit merge [branchname]\n\n\n\n\nRemote Branches\n2\n\n\n# delete remote branches\ngit push origin --delete [branchname]\n\n\n\n\nRepositories\n\n\n\n\nwhat is \norigin\n?\n\n\n\n\n# view remote branches\ngit remote -v\n# add remote branches\ngit remote add [repositoryname] [branch_url]\n# clone a repository into a new directory\ngit clone\n# push to repository\ngit push [repositoryname] [branchname]\ngit pull\n\n\n\n\nBranch Naming Convention\n\n\n\n\nChoose \nshort\n and \ndescriptive\n names:\n\n\n\n\n# good\n$ git checkout -b oauth-migration\n\n# bad - too vague\n$ git checkout -b login_fix\n\n\n\n\n\n\nIdentifiers from corresponding tickets in an external service (eg. a GitHub issue) are also good candidates for use in branch names. For example:\n\n\n\n\n# GitHub issue #15\n$ git checkout -b issue-15\n\n\n\n\n\n\n\n\nUse \ndashes\n to separate words.\n\n\n\n\n\n\nWhen several people are working on the same feature, it might be convenient to have personal feature branches and a team-wide feature branch. Use the following naming convention:\n\n\n\n\n\n\n$ git checkout -b feature-a/master # team-wide branch\n$ git checkout -b feature-a/maria  # Maria's personal branch\n$ git checkout -b feature-a/nick   # Nick's personal branch\nMerge at will the personal branches to the team-wide branch (see \nMerging\n). Eventually, the team-wide branch will be merged to \nmaster\n.\n\n\n\n\n\n\n\n\nDelete your branch from the upstream repository after it's merged, unless there is a specific reason not to.\n\n\n\n\n\n\nTip: Use the following command while being on \"master\", to list merged branches:\n\n\n\n\n\n\n$ git branch --merged | grep -v \n\\*\n\n\n\n\n\nCreate an archive\n\n\n9\n \n10\n\n\n# Create an archive of files from a named tree\ngit archive --format=zip HEAD \n app.zip\n\n\n\n\nFork \n Request\n\n\n11\n \n12\n\n\n\n\nIn a repository you want to fork, click \nFork\n button. It will create your own repository\n\n\nRun this:\n\n\n\n\ngit remote add origin [your_repository] # that have created when you fork\ngit remote add upstream [original_repository] # the repository that you have fork\n\n\n\n\n\n\nCode in your own repository \n commit\n\n\nGo to your Fork repository\n\n\nSwitch to your branch\n\n\nCreate Pull Request\n to send a merge request to the owner of the original repository\n\n\n\n\n\n\n\n\n\n\n\n\nhttps://www.atlassian.com/git/tutorials/using-branches/\n\n\n\n\n\n\nhttp://stackoverflow.com/questions/2003505/delete-a-git-branch-both-locally-and-remotely/2003515#2003515\n\n\n\n\n\n\nhttps://guides.github.com/features/issues/\n\n\n\n\n\n\nhttps://help.github.com/articles/using-pull-requests/\n\n\n\n\n\n\nhttps://help.github.com/articles/about-github-wikis/\n\n\n\n\n\n\nhttps://help.github.com/articles/about-repository-graphs/\n\n\n\n\n\n\nClosing an issue in the same repository\n\n\n\n\n\n\nGit Tools - Submodules\n\n\n\n\n\n\nGit: how to get all the files changed and new files in a folder or zip?\n\n\n\n\n\n\ngit-scm.com: git-archive\n\n\n\n\n\n\nForking a Repo\n\n\n\n\n\n\nUsing pull request", 
            "title": "Git Branching"
        }, 
        {
            "location": "/branch/#branches", 
            "text": "A  branch  represents an independent line of development. Branches serve as an abstraction for the  edit   stage   commit  process discussed in Git Basics, the first module of this series. You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.  git branches diagram   Local Branches  # view branches\ngit branch\n# create new branch\ngit checkout -b [branchname]\n# switch to a branch\ngit checkout [branchname]\n# delete branch\ngit branch -D [branchname]  Merge Branches  git merge [branchname]  Remote Branches 2  # delete remote branches\ngit push origin --delete [branchname]", 
            "title": "Branches"
        }, 
        {
            "location": "/branch/#repositories", 
            "text": "what is  origin ?   # view remote branches\ngit remote -v\n# add remote branches\ngit remote add [repositoryname] [branch_url]\n# clone a repository into a new directory\ngit clone\n# push to repository\ngit push [repositoryname] [branchname]\ngit pull", 
            "title": "Repositories"
        }, 
        {
            "location": "/branch/#branch-naming-convention", 
            "text": "Choose  short  and  descriptive  names:   # good\n$ git checkout -b oauth-migration\n\n# bad - too vague\n$ git checkout -b login_fix   Identifiers from corresponding tickets in an external service (eg. a GitHub issue) are also good candidates for use in branch names. For example:   # GitHub issue #15\n$ git checkout -b issue-15    Use  dashes  to separate words.    When several people are working on the same feature, it might be convenient to have personal feature branches and a team-wide feature branch. Use the following naming convention:    $ git checkout -b feature-a/master # team-wide branch\n$ git checkout -b feature-a/maria  # Maria's personal branch\n$ git checkout -b feature-a/nick   # Nick's personal branch\nMerge at will the personal branches to the team-wide branch (see  Merging ). Eventually, the team-wide branch will be merged to  master .    Delete your branch from the upstream repository after it's merged, unless there is a specific reason not to.    Tip: Use the following command while being on \"master\", to list merged branches:    $ git branch --merged | grep -v  \\*", 
            "title": "Branch Naming Convention"
        }, 
        {
            "location": "/branch/#create-an-archive", 
            "text": "9   10  # Create an archive of files from a named tree\ngit archive --format=zip HEAD   app.zip", 
            "title": "Create an archive"
        }, 
        {
            "location": "/branch/#fork-request", 
            "text": "11   12   In a repository you want to fork, click  Fork  button. It will create your own repository  Run this:   git remote add origin [your_repository] # that have created when you fork\ngit remote add upstream [original_repository] # the repository that you have fork   Code in your own repository   commit  Go to your Fork repository  Switch to your branch  Create Pull Request  to send a merge request to the owner of the original repository       https://www.atlassian.com/git/tutorials/using-branches/    http://stackoverflow.com/questions/2003505/delete-a-git-branch-both-locally-and-remotely/2003515#2003515    https://guides.github.com/features/issues/    https://help.github.com/articles/using-pull-requests/    https://help.github.com/articles/about-github-wikis/    https://help.github.com/articles/about-repository-graphs/    Closing an issue in the same repository    Git Tools - Submodules    Git: how to get all the files changed and new files in a folder or zip?    git-scm.com: git-archive    Forking a Repo    Using pull request", 
            "title": "Fork &amp; Request"
        }, 
        {
            "location": "/github/", 
            "text": "Power Tools with Github\n\n\n Issues\n\n\n\n\nIssues are a great way to keep track of tasks, enhancements, and bugs for your projects. They re kind of like email except they can be shared and discussed with the rest of your team. Most software projects have a bug tracker of some kind. GitHub's tracker is called \nIssues\n, and has its own section in every repository.\n\n\n\n\n\n\nCommit to fix issue\n\n\ngit commit -m \nfix #34\n\n\n\n\n\nMilestones\n\n\nOnce you've collected a lot of issues, you may find it hard to find the ones you care about. \nMilestones\n, labels, and assignees are great features to filter and categorize issues. A \nmilestone\n acts like a container for issues. This is useful for associating issues with specific features or project phases\n\n\n \n\ufffd[^5] \n\n\nPull Requests\n\n\nPull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.\n\n\n\n\n\n\nWiki\n\n\nJust as writing good code and great tests are important, excellent documentation helps others use and extend your project.\n\n\n\nEvery GitHub repository comes equipped with a section for hosting documentation, called a \nwiki\n.\n\n\n \n\n\n\n\nRepository Graphs\n\n\nEvery repository has \ngraphs\n that display data about traffic, contributors, and commits.", 
            "title": "Github"
        }, 
        {
            "location": "/github/#power-tools-with-github", 
            "text": "", 
            "title": "Power Tools with Github"
        }, 
        {
            "location": "/github/#issues", 
            "text": "Issues are a great way to keep track of tasks, enhancements, and bugs for your projects. They re kind of like email except they can be shared and discussed with the rest of your team. Most software projects have a bug tracker of some kind. GitHub's tracker is called  Issues , and has its own section in every repository.    Commit to fix issue  git commit -m  fix #34", 
            "title": " Issues"
        }, 
        {
            "location": "/github/#milestones", 
            "text": "Once you've collected a lot of issues, you may find it hard to find the ones you care about.  Milestones , labels, and assignees are great features to filter and categorize issues. A  milestone  acts like a container for issues. This is useful for associating issues with specific features or project phases    \ufffd[^5]", 
            "title": "Milestones"
        }, 
        {
            "location": "/github/#pull-requests", 
            "text": "Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.", 
            "title": "Pull Requests"
        }, 
        {
            "location": "/github/#wiki", 
            "text": "Just as writing good code and great tests are important, excellent documentation helps others use and extend your project.  Every GitHub repository comes equipped with a section for hosting documentation, called a  wiki .", 
            "title": "Wiki"
        }, 
        {
            "location": "/github/#repository-graphs", 
            "text": "Every repository has  graphs  that display data about traffic, contributors, and commits.", 
            "title": "Repository Graphs"
        }
    ]
}