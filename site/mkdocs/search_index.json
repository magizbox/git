{
    "docs": [
        {
            "location": "/", 
            "text": "What is Git?\n\n\n\n\nGit is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses\n\n\n\n\n\n\n\n\nVideos\n\n\n\n\n\n\n\n\nExternal Links\n\n\n\n\nhttps://git-scm.com/\n\n\nOfficial Git Tutorial\n\n\nRy\u2019s Git Tutorial", 
            "title": "Home"
        }, 
        {
            "location": "/#what-is-git", 
            "text": "Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.", 
            "title": "What is Git?"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/#videos", 
            "text": "", 
            "title": "Videos"
        }, 
        {
            "location": "/#external-links", 
            "text": "https://git-scm.com/  Official Git Tutorial  Ry\u2019s Git Tutorial", 
            "title": "External Links"
        }, 
        {
            "location": "/install/", 
            "text": "Windows\n\n\nStep 1. Download the \nGit for Windows installer package\n.\n\n\nStep 2. When you've successfully started the installer, you should see the Git Setup wizard screen. Follow the Next and Finish prompts to complete the installation.\n\n\n\n\nStep 3.Open Git Bash.vbs from the Git folder of the Programs directory to open a command window.\n\n\n\n\nStep 4. Configure your username using the following command\n\n\n$ git config --global user.name \nyour_name\n\n\n\n\n\nStep 5. Configure your email address using the following command\n\n\n$ git config --global user.email \nyour_email\n\n\n\n\n\nLinux\n\n\nStep 1. Enter the following command to install Git:\n\n\n$ sudo apt-get install git\n\n\n\n\nStep 2. Verify the installation was successful by typing which git at the command line.\n\n\n$ which git\n/opt/local/bin/git\n\n\n\n\nStep 3. Configure your username using the following command.\n\n\n$ git config --global user.name \nEmma Paris\n\n\n\n\n\nStep 4. Configure your email address using the following command.\n\n\n$ git config --global user.email \neparis@atlassian.com", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#windows", 
            "text": "Step 1. Download the  Git for Windows installer package .  Step 2. When you've successfully started the installer, you should see the Git Setup wizard screen. Follow the Next and Finish prompts to complete the installation.   Step 3.Open Git Bash.vbs from the Git folder of the Programs directory to open a command window.   Step 4. Configure your username using the following command  $ git config --global user.name  your_name   Step 5. Configure your email address using the following command  $ git config --global user.email  your_email", 
            "title": "Windows"
        }, 
        {
            "location": "/install/#linux", 
            "text": "Step 1. Enter the following command to install Git:  $ sudo apt-get install git  Step 2. Verify the installation was successful by typing which git at the command line.  $ which git\n/opt/local/bin/git  Step 3. Configure your username using the following command.  $ git config --global user.name  Emma Paris   Step 4. Configure your email address using the following command.  $ git config --global user.email  eparis@atlassian.com", 
            "title": "Linux"
        }, 
        {
            "location": "/commit/", 
            "text": "Commit\n\n\n1\n\n\n\n\n# Add file contents to the index\ngit add [filename]\n# Record changes to the repository\ngit commit -m [message]\n# Reset current HEAD to the specified state\ngit reset HEAD~1\n# Switch branches or restore working tree files\ngit checkout HEAD~2\n\n\n\n\nView Status\n\n\ngit status\ngit log\ngit log --since=2015-12-01\ngit log --until=2015-12-01\ngit log --author=\nmagizbox\n\ngit log --grep=\nInit\n\ngit log --oneline origin/master\n\n\n\n\n\n\n\n\n\n\n\n\nhttp://git-scm.com/book/ca/v1/Git-Basics-Recording-Changes-to-the-Repository", 
            "title": "Commit"
        }, 
        {
            "location": "/commit/#commit", 
            "text": "1   # Add file contents to the index\ngit add [filename]\n# Record changes to the repository\ngit commit -m [message]\n# Reset current HEAD to the specified state\ngit reset HEAD~1\n# Switch branches or restore working tree files\ngit checkout HEAD~2", 
            "title": "Commit"
        }, 
        {
            "location": "/commit/#view-status", 
            "text": "git status\ngit log\ngit log --since=2015-12-01\ngit log --until=2015-12-01\ngit log --author= magizbox \ngit log --grep= Init \ngit log --oneline origin/master      http://git-scm.com/book/ca/v1/Git-Basics-Recording-Changes-to-the-Repository", 
            "title": "View Status"
        }, 
        {
            "location": "/branch/", 
            "text": "Branches\n\n\nA \nbranch\n represents an independent line of development. Branches serve as an abstraction for the \nedit \n stage \n commit\n process discussed in Git Basics, the first module of this series. You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.\n\n\ngit branches diagram\n\n\n\n\n\n\nLocal Branches\n\n\n# view branches\ngit branch\n# create new branch\ngit checkout -b [branchname]\n# switch to a branch\ngit checkout [branchname]\n# delete branch\ngit branch -D [branchname]\n\n\n\n\nMerge Branches\n\n\ngit merge [branchname]\n\n\n\n\nRemote Branches\n\n\n2\n\n\n# delete remote branches\ngit push origin --delete [branchname]\n\n\n\n\nRepositories\n\n\n\n\n  what is \norigin\n?\n\n\n\n\n# view remote branches\ngit remote -v\n# add remote branches\ngit remote add [repositoryname] [branch_url]\n# clone a repository into a new directory\ngit clone\n# push to repository\ngit push [repositoryname] [branchname]\ngit pull\n\n\n\n\nTips\n\n\n9\n \n10\n\n\n# Create an archive of files from a named tree\ngit archive --format=zip HEAD \n app.zip\n\n\n\n\nDev \n Release with Git\n\n\n\n\nFork\n \n create a \nPull Request\n with Github\n\n\n11\n \n12\n\n\n\n\nIn a reposiroty you want to fork, click \nFork\n button. It will create your own repository\n\n\nRun this:\n\n\n\n\ngit remote add origin [your_repository] # that have created when you fork\ngit remote add upstream [original_repository] # the repository that you have fork\n\n\n\n\n\n\nCode in your own repository \n commit\n\n\nGo to your Fork repository\n\n\nSwitch to your branch\n\n\nCreate Pull Request\n to send a merge request to the owner of the original repository\n\n\n\n\nDescription\n\n\n\n\nDevelopment Branch\n\n\nIt use for debugging, coding, testing\n\n\nIt must have \ncode\n and \ntests\n\n\nRelease Branch\n\n\nIt use for running, including\n\n\nIt must have \ndocuments\n (\nAPI.md\n, \nHOW_TO_INSTALL.md\n, \nHOW_TO_RUN.md\n) and \nresources\n (executable and resource files) in \nrelease\n folder.\n\n\nRelease Branch doesn't care about code. It only care about \nrelease\n folder.\n\n\n\n\nRule of thumb\n\n\n\n\nRule 1: Don't code in 2 \ndev\n components at the same time. Do write tests instead.\n\n\nRule 2: Do pull \nrelease\n before switch code from a component to other.\n\n\nRule 3: Do include \nrelease\n version of other components in case reuse (component A include component B).\n\n\nRule 4: Don't \ncode\n and \ndebug\n in \nrelease\n branch, only \nmerge\n  or \npull\n (from \ndev\n)\n\n\n\n\n\n\n\n\n\n\n\n\nhttps://www.atlassian.com/git/tutorials/using-branches/\n\n\n\n\n\n\nhttp://stackoverflow.com/questions/2003505/delete-a-git-branch-both-locally-and-remotely/2003515#2003515\n\n\n\n\n\n\nhttps://guides.github.com/features/issues/\n\n\n\n\n\n\nhttps://help.github.com/articles/using-pull-requests/\n\n\n\n\n\n\nhttps://help.github.com/articles/about-github-wikis/\n\n\n\n\n\n\nhttps://help.github.com/articles/about-repository-graphs/\n\n\n\n\n\n\nClosing an issue in the same repository\n\n\n\n\n\n\nGit Tools - Submodules\n\n\n\n\n\n\nGit: how to get all the files changed and new files in a folder or zip?\n\n\n\n\n\n\ngit-scm.com: git-archive\n\n\n\n\n\n\nForking a Repo\n\n\n\n\n\n\nUsing pull request", 
            "title": "Branch"
        }, 
        {
            "location": "/branch/#branches", 
            "text": "A  branch  represents an independent line of development. Branches serve as an abstraction for the  edit   stage   commit  process discussed in Git Basics, the first module of this series. You can think of them as a way to request a brand new working directory, staging area, and project history. New commits are recorded in the history for the current branch, which results in a fork in the history of the project.  git branches diagram   Local Branches  # view branches\ngit branch\n# create new branch\ngit checkout -b [branchname]\n# switch to a branch\ngit checkout [branchname]\n# delete branch\ngit branch -D [branchname]  Merge Branches  git merge [branchname]  Remote Branches  2  # delete remote branches\ngit push origin --delete [branchname]", 
            "title": "Branches"
        }, 
        {
            "location": "/branch/#tips", 
            "text": "9   10  # Create an archive of files from a named tree\ngit archive --format=zip HEAD   app.zip", 
            "title": "Tips"
        }, 
        {
            "location": "/branch/#dev-release-with-git", 
            "text": "", 
            "title": "Dev &amp; Release with Git"
        }, 
        {
            "location": "/branch/#fork-create-a-pull-request-with-github", 
            "text": "11   12   In a reposiroty you want to fork, click  Fork  button. It will create your own repository  Run this:   git remote add origin [your_repository] # that have created when you fork\ngit remote add upstream [original_repository] # the repository that you have fork   Code in your own repository   commit  Go to your Fork repository  Switch to your branch  Create Pull Request  to send a merge request to the owner of the original repository", 
            "title": "Fork &amp; create a Pull Request with Github"
        }, 
        {
            "location": "/branch/#description", 
            "text": "Development Branch  It use for debugging, coding, testing  It must have  code  and  tests  Release Branch  It use for running, including  It must have  documents  ( API.md ,  HOW_TO_INSTALL.md ,  HOW_TO_RUN.md ) and  resources  (executable and resource files) in  release  folder.  Release Branch doesn't care about code. It only care about  release  folder.", 
            "title": "Description"
        }, 
        {
            "location": "/branch/#rule-of-thumb", 
            "text": "Rule 1: Don't code in 2  dev  components at the same time. Do write tests instead.  Rule 2: Do pull  release  before switch code from a component to other.  Rule 3: Do include  release  version of other components in case reuse (component A include component B).  Rule 4: Don't  code  and  debug  in  release  branch, only  merge   or  pull  (from  dev )       https://www.atlassian.com/git/tutorials/using-branches/    http://stackoverflow.com/questions/2003505/delete-a-git-branch-both-locally-and-remotely/2003515#2003515    https://guides.github.com/features/issues/    https://help.github.com/articles/using-pull-requests/    https://help.github.com/articles/about-github-wikis/    https://help.github.com/articles/about-repository-graphs/    Closing an issue in the same repository    Git Tools - Submodules    Git: how to get all the files changed and new files in a folder or zip?    git-scm.com: git-archive    Forking a Repo    Using pull request", 
            "title": "Rule of thumb"
        }, 
        {
            "location": "/tag/", 
            "text": "Tagging\n\n\nSource: \nGit-Basics-Tagging\n\n\nLike most VCSs, Git has the ability to tag specific points in history as being important. Typically people use this functionality to mark release points (v1.0, and so on). In this section, you\u2019ll learn how to list the available tags, how to create new tags, and what the different types of tags are.\n\n\nListing Your Tags\n\n\nListing the available tags in Git is straightforward. Just type git tag:\n\n\n$ git tag\nv0.1\nv1.3\n\n\n\n\nThis command lists the tags in alphabetical order; the order in which they appear has no real importance.\n\n\nYou can also search for tags with a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you\u2019re only interested in looking at the 1.8.5 series, you can run this:\n\n\n$ git tag -l \nv1.8.5*\n\nv1.8.5\nv1.8.5-rc0\nv1.8.5-rc1\nv1.8.5-rc2\nv1.8.5-rc3\nv1.8.5.1\nv1.8.5.2\nv1.8.5.3\nv1.8.5.4\nv1.8.5.5\n\n\n\n\nCreating Tags\n\n\nGit uses two main types of tags: lightweight and annotated.\n\n\nA lightweight tag is very much like a branch that doesn\u2019t change \u2013 it\u2019s just a pointer to a specific commit.\n\n\nAnnotated tags, however, are stored as full objects in the Git database. They\u2019re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It\u2019s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don\u2019t want to keep the other information, lightweight tags are available too.\n\n\nAnnotated Tags\n\n\nCreating an annotated tag in Git is simple. The easiest way is to specify -a when you run the tag command:\n\n\n$ git tag -a v1.4 -m \nmy version 1.4\n\n$ git tag\nv0.1\nv1.3\nv1.4\n\n\n\n\nThe -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in.\n\n\nYou can see the tag data along with the commit that was tagged by using the git show command:\n\n\n$ git show v1.4\ntag v1.4\nTagger: Ben Straub \nben@straub.cc\n\nDate:   Sat May 3 20:19:12 2014 -0700\n\nmy version 1.4\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon \nschacon@gee-mail.com\n\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n\n\n\n\nThat shows the tagger information, the date the commit was tagged, and the annotation message before showing the commit information.\n\n\nLightweight Tags\n\n\nAnother way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file \u2013 no other information is kept. To create a lightweight tag, don\u2019t supply the -a, -s, or -m option:\n\n\n$ git tag v1.4-lw\n$ git tag\nv0.1\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n\n\n\nThis time, if you run git show on the tag, you don\u2019t see the extra tag information. The command just shows the commit:\n\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon \nschacon@gee-mail.com\n\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number\n\n\n\n\nTagging Later\n\n\nYou can also tag commits after you\u2019ve moved past them. Suppose your commit history looks like this:\n\n\n$ git log --pretty=oneline\n15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\na6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\n0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\n6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\n4682c3261057305bdd616e23b64b0857d832627b added a todo file\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n\n\nNow, suppose you forgot to tag the project at v1.2, which was at the \u201cupdated rakefile\u201d commit. You can add it after the fact. To tag that commit, you specify the commit checksum (or part of it) at the end of the command:\n\n\n$ git tag -a v1.2 9fceb02\n\n\n\n\nYou can see that you\u2019ve tagged the commit:\n\n\n$ git tag\nv0.1\nv1.2\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n$ git show v1.2\ntag v1.2\nTagger: Scott Chacon \nschacon@gee-mail.com\n\nDate:   Mon Feb 9 15:32:16 2009 -0800\n\nversion 1.2\ncommit 9fceb02d0ae598e95dc970b74767f19372d61af8\nAuthor: Magnus Chacon \nmchacon@gee-mail.com\n\nDate:   Sun Apr 27 20:43:35 2008 -0700\n\n    updated rakefile\n...\n\n\n\n\nSharing Tags\n\n\nBy default, the git push command doesn\u2019t transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches \u2013 you can run git push origin [tagname].\n\n\n$ git push origin v1.5\nCounting objects: 14, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (12/12), done.\nWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\nTotal 14 (delta 3), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.5 -\n v1.5\n\n\n\n\nIf you have a lot of tags that you want to push up at once, you can also use the --tags option to the git push command. This will transfer all of your tags to the remote server that are not already there.\n\n\n$ git push origin --tags\nCounting objects: 1, done.\nWriting objects: 100% (1/1), 160 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.4 -\n v1.4\n * [new tag]         v1.4-lw -\n v1.4-lw\n\n\n\n\nNow, when someone else clones or pulls from your repository, they will get all your tags as well.\n\n\nChecking out Tags\n\n\nYou can\u2019t really check out a tag in Git, since they can\u2019t be moved around. If you want to put a version of your repository in your working directory that looks like a specific tag, you can create a new branch at a specific tag with git checkout -b [branchname] [tagname]:\n\n\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n\n\n\n\nOf course if you do this and do a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.", 
            "title": "Tag"
        }, 
        {
            "location": "/tag/#tagging", 
            "text": "Source:  Git-Basics-Tagging  Like most VCSs, Git has the ability to tag specific points in history as being important. Typically people use this functionality to mark release points (v1.0, and so on). In this section, you\u2019ll learn how to list the available tags, how to create new tags, and what the different types of tags are.", 
            "title": "Tagging"
        }, 
        {
            "location": "/tag/#listing-your-tags", 
            "text": "Listing the available tags in Git is straightforward. Just type git tag:  $ git tag\nv0.1\nv1.3  This command lists the tags in alphabetical order; the order in which they appear has no real importance.  You can also search for tags with a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you\u2019re only interested in looking at the 1.8.5 series, you can run this:  $ git tag -l  v1.8.5* \nv1.8.5\nv1.8.5-rc0\nv1.8.5-rc1\nv1.8.5-rc2\nv1.8.5-rc3\nv1.8.5.1\nv1.8.5.2\nv1.8.5.3\nv1.8.5.4\nv1.8.5.5", 
            "title": "Listing Your Tags"
        }, 
        {
            "location": "/tag/#creating-tags", 
            "text": "Git uses two main types of tags: lightweight and annotated.  A lightweight tag is very much like a branch that doesn\u2019t change \u2013 it\u2019s just a pointer to a specific commit.  Annotated tags, however, are stored as full objects in the Git database. They\u2019re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It\u2019s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don\u2019t want to keep the other information, lightweight tags are available too.", 
            "title": "Creating Tags"
        }, 
        {
            "location": "/tag/#annotated-tags", 
            "text": "Creating an annotated tag in Git is simple. The easiest way is to specify -a when you run the tag command:  $ git tag -a v1.4 -m  my version 1.4 \n$ git tag\nv0.1\nv1.3\nv1.4  The -m specifies a tagging message, which is stored with the tag. If you don\u2019t specify a message for an annotated tag, Git launches your editor so you can type it in.  You can see the tag data along with the commit that was tagged by using the git show command:  $ git show v1.4\ntag v1.4\nTagger: Ben Straub  ben@straub.cc \nDate:   Sat May 3 20:19:12 2014 -0700\n\nmy version 1.4\n\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon  schacon@gee-mail.com \nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number  That shows the tagger information, the date the commit was tagged, and the annotation message before showing the commit information.", 
            "title": "Annotated Tags"
        }, 
        {
            "location": "/tag/#lightweight-tags", 
            "text": "Another way to tag commits is with a lightweight tag. This is basically the commit checksum stored in a file \u2013 no other information is kept. To create a lightweight tag, don\u2019t supply the -a, -s, or -m option:  $ git tag v1.4-lw\n$ git tag\nv0.1\nv1.3\nv1.4\nv1.4-lw\nv1.5  This time, if you run git show on the tag, you don\u2019t see the extra tag information. The command just shows the commit:  $ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon  schacon@gee-mail.com \nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the version number", 
            "title": "Lightweight Tags"
        }, 
        {
            "location": "/tag/#tagging-later", 
            "text": "You can also tag commits after you\u2019ve moved past them. Suppose your commit history looks like this:  $ git log --pretty=oneline\n15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'\na6b4c97498bd301d84096da251c98a07c7723e65 beginning write support\n0d52aaab4479697da7686c15f77a3d64d9165190 one more thing\n6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'\n0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function\n4682c3261057305bdd616e23b64b0857d832627b added a todo file\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme  Now, suppose you forgot to tag the project at v1.2, which was at the \u201cupdated rakefile\u201d commit. You can add it after the fact. To tag that commit, you specify the commit checksum (or part of it) at the end of the command:  $ git tag -a v1.2 9fceb02  You can see that you\u2019ve tagged the commit:  $ git tag\nv0.1\nv1.2\nv1.3\nv1.4\nv1.4-lw\nv1.5\n\n$ git show v1.2\ntag v1.2\nTagger: Scott Chacon  schacon@gee-mail.com \nDate:   Mon Feb 9 15:32:16 2009 -0800\n\nversion 1.2\ncommit 9fceb02d0ae598e95dc970b74767f19372d61af8\nAuthor: Magnus Chacon  mchacon@gee-mail.com \nDate:   Sun Apr 27 20:43:35 2008 -0700\n\n    updated rakefile\n...", 
            "title": "Tagging Later"
        }, 
        {
            "location": "/tag/#sharing-tags", 
            "text": "By default, the git push command doesn\u2019t transfer tags to remote servers. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches \u2013 you can run git push origin [tagname].  $ git push origin v1.5\nCounting objects: 14, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (12/12), done.\nWriting objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.\nTotal 14 (delta 3), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.5 -  v1.5  If you have a lot of tags that you want to push up at once, you can also use the --tags option to the git push command. This will transfer all of your tags to the remote server that are not already there.  $ git push origin --tags\nCounting objects: 1, done.\nWriting objects: 100% (1/1), 160 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo git@github.com:schacon/simplegit.git\n * [new tag]         v1.4 -  v1.4\n * [new tag]         v1.4-lw -  v1.4-lw  Now, when someone else clones or pulls from your repository, they will get all your tags as well.", 
            "title": "Sharing Tags"
        }, 
        {
            "location": "/tag/#checking-out-tags", 
            "text": "You can\u2019t really check out a tag in Git, since they can\u2019t be moved around. If you want to put a version of your repository in your working directory that looks like a specific tag, you can create a new branch at a specific tag with git checkout -b [branchname] [tagname]:  $ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'  Of course if you do this and do a commit, your version2 branch will be slightly different than your v2.0.0 tag since it will move forward with your new changes, so do be careful.", 
            "title": "Checking out Tags"
        }, 
        {
            "location": "/submodule/", 
            "text": "Git Sub Module\n\n\nAdd new submodule\n\n\ngit submodule add https://github.com/chaconinc/DbConnector\n\n\n\n\nUpdate submodule\n\n\ngit submodule init\ngit submodule update", 
            "title": "Submodule"
        }, 
        {
            "location": "/submodule/#git-sub-module", 
            "text": "", 
            "title": "Git Sub Module"
        }, 
        {
            "location": "/submodule/#add-new-submodule", 
            "text": "git submodule add https://github.com/chaconinc/DbConnector", 
            "title": "Add new submodule"
        }, 
        {
            "location": "/submodule/#update-submodule", 
            "text": "git submodule init\ngit submodule update", 
            "title": "Update submodule"
        }, 
        {
            "location": "/config/", 
            "text": "Git Configurations\n\n\nKnown Issues\n\n\n\n\nHow do I force git to use LF instead of CR+LF under windows?\n\n\n\n\ngit config --global core.autocrlf false", 
            "title": "Config"
        }, 
        {
            "location": "/config/#git-configurations", 
            "text": "Known Issues   How do I force git to use LF instead of CR+LF under windows?   git config --global core.autocrlf false", 
            "title": "Git Configurations"
        }, 
        {
            "location": "/github/", 
            "text": "Power Tools with Github\n\n\n Issues\n\n\n\n\nIssues are a great way to keep track of tasks, enhancements, and bugs for your projects. They re kind of like email except they can be shared and discussed with the rest of your team. Most software projects have a bug tracker of some kind. GitHub's tracker is called \nIssues\n, and has its own section in every repository.\n\n\n\n\n\n\nCommit to fix issue\n\n\ngit commit -m \nfix #34\n\n\n\n\n\nMilestones\n\n\nOnce you've collected a lot of issues, you may find it hard to find the ones you care about. \nMilestones\n, labels, and assignees are great features to filter and categorize issues. A \nmilestone\n acts like a container for issues. This is useful for associating issues with specific features or project phases\n\n\n \n\ufffd[^5] \n\n\nPull Requests\n\n\nPull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.\n\n\n\n\n\n\nWiki\n\n\nJust as writing good code and great tests are important, excellent documentation helps others use and extend your project.\n\n\n\nEvery GitHub repository comes equipped with a section for hosting documentation, called a \nwiki\n.\n\n\n \n\n\n\n\nRepository Graphs\n\n\nEvery repository has \ngraphs\n that display data about traffic, contributors, and commits.", 
            "title": "Github"
        }, 
        {
            "location": "/github/#power-tools-with-github", 
            "text": "", 
            "title": "Power Tools with Github"
        }, 
        {
            "location": "/github/#issues", 
            "text": "Issues are a great way to keep track of tasks, enhancements, and bugs for your projects. They re kind of like email except they can be shared and discussed with the rest of your team. Most software projects have a bug tracker of some kind. GitHub's tracker is called  Issues , and has its own section in every repository.    Commit to fix issue  git commit -m  fix #34", 
            "title": " Issues"
        }, 
        {
            "location": "/github/#milestones", 
            "text": "Once you've collected a lot of issues, you may find it hard to find the ones you care about.  Milestones , labels, and assignees are great features to filter and categorize issues. A  milestone  acts like a container for issues. This is useful for associating issues with specific features or project phases    \ufffd[^5]", 
            "title": "Milestones"
        }, 
        {
            "location": "/github/#pull-requests", 
            "text": "Pull requests let you tell others about changes you've pushed to a repository on GitHub. Once a pull request is sent, interested parties can review the set of changes, discuss potential modifications, and even push follow-up commits if necessary.", 
            "title": "Pull Requests"
        }, 
        {
            "location": "/github/#wiki", 
            "text": "Just as writing good code and great tests are important, excellent documentation helps others use and extend your project.  Every GitHub repository comes equipped with a section for hosting documentation, called a  wiki .", 
            "title": "Wiki"
        }, 
        {
            "location": "/github/#repository-graphs", 
            "text": "Every repository has  graphs  that display data about traffic, contributors, and commits.", 
            "title": "Repository Graphs"
        }, 
        {
            "location": "/team_workflow/", 
            "text": "Team Workflow\n\n\nIn this article, I will represent our workflow with git to collaboration. As you can see, there are \nupstream\n, \nA\n, \nB\n repositories. Upstream repostiroy is main repository of project, owner by team leader. \nA\n and \nB\n repositories belong to developers. In \nupstream\n remote, there are \nmaster\n and \ndev\n branches. In developer's repositories, there are \ndev\n and \nfeature-something\n branches.\n\n\n\n\nStep 1: Create new project\n\n\nIn step 1, leader create a repository.\n\n\n\n\nStep 2: Forking\n\n\nIn step 2, each developers create their own repository by forking main repository\n\n\n\n\nStep 3: Commits\n\n\nIn step 3, developers work on their branches, each peace of their works should be end by a \ncommit\n\n\n\n\nStep 4: Merge Requests\n\n\nAfter finish a feature, each developer will create a \nmerge requests\n to main repository. Leader take responsibility for merging their requests\n\n\n\n\nStep 5: fetch and rebase\n\n\nDeveloper will checkout to dev \nbranch\n, fetch from upstream remote and rebase\n\n\n\n\nStep 6: Develop new features\n\n\nTeam sync\n. At this moment, developer can \ncheckout\n from dev feature to create new feature.\n\n\n\n\nStep 7: New version\n\n\nLeader take responsibility to merge from dev branch to master branch and create tag to release new version.", 
            "title": "Workflow"
        }, 
        {
            "location": "/team_workflow/#team-workflow", 
            "text": "In this article, I will represent our workflow with git to collaboration. As you can see, there are  upstream ,  A ,  B  repositories. Upstream repostiroy is main repository of project, owner by team leader.  A  and  B  repositories belong to developers. In  upstream  remote, there are  master  and  dev  branches. In developer's repositories, there are  dev  and  feature-something  branches.", 
            "title": "Team Workflow"
        }, 
        {
            "location": "/team_workflow/#step-1-create-new-project", 
            "text": "In step 1, leader create a repository.", 
            "title": "Step 1: Create new project"
        }, 
        {
            "location": "/team_workflow/#step-2-forking", 
            "text": "In step 2, each developers create their own repository by forking main repository", 
            "title": "Step 2: Forking"
        }, 
        {
            "location": "/team_workflow/#step-3-commits", 
            "text": "In step 3, developers work on their branches, each peace of their works should be end by a  commit", 
            "title": "Step 3: Commits"
        }, 
        {
            "location": "/team_workflow/#step-4-merge-requests", 
            "text": "After finish a feature, each developer will create a  merge requests  to main repository. Leader take responsibility for merging their requests", 
            "title": "Step 4: Merge Requests"
        }, 
        {
            "location": "/team_workflow/#step-5-fetch-and-rebase", 
            "text": "Developer will checkout to dev  branch , fetch from upstream remote and rebase", 
            "title": "Step 5: fetch and rebase"
        }, 
        {
            "location": "/team_workflow/#step-6-develop-new-features", 
            "text": "Team sync . At this moment, developer can  checkout  from dev feature to create new feature.", 
            "title": "Step 6: Develop new features"
        }, 
        {
            "location": "/team_workflow/#step-7-new-version", 
            "text": "Leader take responsibility to merge from dev branch to master branch and create tag to release new version.", 
            "title": "Step 7: New version"
        }
    ]
}